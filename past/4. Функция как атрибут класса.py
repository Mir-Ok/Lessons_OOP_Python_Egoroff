# внутри класса можно объявлять не только переменные, но и функции

class Car:
    model = 'BMW'
    engine = 1.6

    def drive():  # при создании автоматически создается параметр self, пока удалим, далее изучим подробнее
        print('Let"s go')

print(Car.drive())  # --> Let"s go None

print(getattr(Car,'drive')())  # --> Let"s go None вызов функции через функцию, не забываем ()

a = Car()
print(a.__dict__)  # --> {} в пространстве имен экземпляра ничего нет,
                          # но мы можем обратится к пр. имен вмещающего класса

print(a.drive) # --> <bound method Car.drive of <__main__.Car object at 0x000001A205907400>>
               # то, что для класса функция - стало методом для ее переменной,
               # поэтому вызвать функцию через экземпляр НЕЛЬЗЯ

''' Чтобы сделать функцию доступной от экземпляра, и от класса одновременно,
    используем декоратор @staticmethod
    '''

class Car:
    model = 'BMW'
    engine = 1.6

    @staticmethod
    def drive():  # при создании автоматически создается параметр self, пока удалим, далее изучим подробнее
        print('Let"s go')