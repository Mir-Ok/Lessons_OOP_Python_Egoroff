''' Методам, созданным внутри класса, недоступны атрибуты самого класса, как это бывает с
    обычными функциями вне класса

    То есть даже если мы атрибуты класса вынесем за класс и они станут просто переменными документа, даже в этом случае
    методы смогут их "видеть"

    Что делать?

    Вариант 1. Обратится к атрибутам класса в теле метода через self.
    Это сработает, потому что не найдя их в методе, Питон пойдет искатьв  класс, на уровень выше
    Без self. он искать выше не ходит

    Вариант 2. Обратится через имя класса Class.

    Вариант 3.
    Добавим декоратор @property, создадим свойство из метода и в него поступит self. и это даст
    нам возможность обратиться

    Вариант 4.
    Добавим декоратор @classmethod
    И тогда мы сможем обратиться к переменным через cls.

    Вариант 5.
    Добавим декоратор @staticmethod
    И тогда мы сможем обратиться к переменным напрямую, т.к. статический метод не принимает аргумент.

    '''

# Разберем еще один пример

''' Что делать, если мы из метода хотим изменить атрибут класса методом класса?
 
    Проблема в том, чтоо мы из метода можем обратиться к атрибуту класса, и даже получить 
    результат, но он не затронет исходник, а создаст свой дубликат, локальный атрибут 
    конкретно этого метода. Это хорошо видно при вызове __dict__ к классу, и к методу
    
    Если мы хотим изменить именно атрибут класса, то обращаемся к нему по полному имени
    через Class.atr и тогда изменится непосредственно атрибут класса, без создания дубликатов
    
    Но если мы меняем глобально атрибут класса, то у НОВЫХ экземпляров он будет измененным, 
    держим это в голове'''