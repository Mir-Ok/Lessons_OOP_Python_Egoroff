class Person:

    def breathe(self):  # доступно и этому классу, и потомку
        print('Человек дышит')

class Doctor(Person):

    def breathe(self):  # доступно и этому классу, и потомку
        print('Доктор дышит')

p = Person()
d = Doctor()

''' На данный момент класс-потомок заоверрайдил (переопределил) метод
    класса-родителя. Поэтому есть разница, у какого объекта метод вызывать. 
    
    Иногда требуется в методе потомка вызвать метод родителя.
    Используем ключевое слово super(). '''

class Person2:

    def breathe(self):  # доступно и этому классу, и потомку
        print('Человек дышит')

class Doctor2(Person2):

    def breathe(self):  # доступно и этому классу, и потомку
        print('Доктор дышит')
        super().breathe()  # вызов этого метода из родителя

e = Doctor2()
e.breathe()  # 1.Доктор дышит   2.Человек дышит
             # по порядку в методе - сначала свой функционал, потом обращение к родителю
             # принципиально можно и наоборот

''' Где часто используется? В меоде __init__ 
    Если просто писать, то будет дублирование кода '''

class Person3:

    def __init__(self, name, surname):
        self.name = name
        self.surname = surname

    def breathe(self):  # доступно и этому классу, и потомку
        print('Человек дышит')

class Doctor3(Person3):

    def __init__(self, name, surname, age):
        # self.name = name
        # self.surname = surname
        super().__init__(name, surname)  # берем метод родителя и подаем в него переменные
        self.age = age

    def breathe(self):  # доступно и этому классу, и потомку
        print('Доктор дышит')
        super().breathe()  # вызов этого метода из родителя

''' Важно понимать, что если мы сначала обратимся к методу-родителю и зададим переменные,
    и после создадим age - это безопаснее, чем наоборот. Убираем вероятность путаницы и лишних
    переопределений атрибутов. Потому что если атрибут age не был задан, то и повлиять на него 
    обращение к родителю не может, не будет потери значения '''